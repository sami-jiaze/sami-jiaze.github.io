(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{460:function(a,e,n){a.exports=n.p+"assets/img/image-20230401160125390.d09dffb0.png"},461:function(a,e,n){a.exports=n.p+"assets/img/image-20230321084803087.b0abc25e.png"},462:function(a,e,n){a.exports=n.p+"assets/img/image-20230321085306628.051fc4c9.png"},671:function(a,e,n){"use strict";n.r(e);var s=n(2),r=Object(s.a)({},(function(){var a=this,e=a._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[a._v("说明")]),a._v(" "),e("p",[a._v("npm,yarn和pnpm、软硬链接、嵌套安装与扁平安装、npx、.npmrc笔记总结")])]),a._v(" "),e("h2",{attrs:{id:"npm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npm"}},[a._v("#")]),a._v(" npm")]),a._v(" "),e("p",[a._v("npm（“Node 包管理器”）是 JavaScript 运行时 Node.js 的默认程序包管理器。")]),a._v(" "),e("p",[a._v("它也被称为“Ninja Pumpkin Mutants”，“Nonprofit Pizza Makers”，以及许多其他随机名称，你可以在  "),e("a",{attrs:{href:"https://github.com/npm/npm-expansions",target:"_blank",rel:"noopener noreferrer"}},[a._v("npm-expansions"),e("OutboundLink")],1),a._v(" 上探索这些名称。")]),a._v(" "),e("p",[a._v("npm 由两个主要部分组成:")]),a._v(" "),e("ul",[e("li",[a._v("用于发布和下载程序包的 CLI（命令行界面）工具")]),a._v(" "),e("li",[a._v("托管 JavaScript 程序包的  "),e("a",{attrs:{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer"}},[a._v("在线存储库"),e("OutboundLink")],1)])]),a._v(" "),e("h2",{attrs:{id:"yarn"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#yarn"}},[a._v("#")]),a._v(" yarn")]),a._v(" "),e("p",[a._v("Yarn 是由 Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具，是为了弥补 npm 的一些缺陷而出现的")]),a._v(" "),e("p",[a._v("安装过的包会被保存进缓存目录，以后安装就直接从缓存中复制过来，这样做的本质还是会提高安装下载的速度，避免不必要的网络请求。")]),a._v(" "),e("h2",{attrs:{id:"嵌套安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#嵌套安装"}},[a._v("#")]),a._v(" 嵌套安装")]),a._v(" "),e("p",[e("em",[a._v("npm@3")]),a._v(" 之前，node_modules 中的"),e("strong",[a._v("每个依赖项")]),a._v("都有自己的"),e("em",[a._v("node_modules")]),a._v("文件夹，在"),e("em",[a._v("package.json中")]),a._v("指定了所有依赖项。例如下面所示，项目依赖了"),e("code",[a._v("foo")]),a._v("，"),e("code",[a._v("foo")]),a._v("又依赖了"),e("code",[a._v("bar")]),a._v("，依赖关系如下图所示")]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("node_modules\n└─ foo\n   ├─ index.js\n   ├─ package.json\n   └─ node_modules\n      └─ bar\n         ├─ index.js\n         └─ package.json\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br")])]),e("p",[a._v("上面结构有两个严重的问题：")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("package中经常创建太深的依赖树，这会导致 Windows 上的目录路径过长问题")])]),a._v(" "),e("li",[e("p",[a._v("当一个package在不同的依赖项中需要时，它会被多次复制粘贴并生成多份文件")])])]),a._v(" "),e("h2",{attrs:{id:"扁平安装"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扁平安装"}},[a._v("#")]),a._v(" 扁平安装")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("优点:")]),a._v(" "),e("p",[a._v("减少不必要的安装，假如A和B都需要依赖C那么扁平的安装就可以让A和B都能使用C，不需要在各自内部文件夹单独安装C")])]),a._v(" "),e("li",[e("p",[a._v("缺点:")]),a._v(" "),e("p",[a._v("幽灵依赖：由于扁平化导致源码可以访问本不属于当前项目所设定的依赖包;")]),a._v(" "),e("p",[a._v("项目里使用了，但是未在项目的package.json 中定义的包。就是幽灵依赖。 按着原理来说 未在package.json中定义的包 不会被下载，但是它偏偏就存在了，也被下载了，这又是为什么呢？ 因为依赖提升，造成的副作用")]),a._v(" "),e("p",[a._v("比如说我们这里有一个项目，安装了 A 这个库，版本是 v1，但是 A 库又依赖一个 B 库，版本也是 v1。")]),a._v(" "),e("p",[a._v("我们项目里明明没有手动安装这个 B 库，但是在项目里边仍然可以去导入它并且使用，这就产生了幽灵依赖。")]),a._v(" "),e("p",[a._v("一旦有一天因为某种原因，我们要把 A 库进行升级，升级的 v2 的版本，v2 这个版本有可能要使用 B 库的 v2 版本，于是 B 库也会跟着升级，而 B 库升级之后，它里边有些 API 可能有变动，那么就会导致我们之前用 B 库的代码全部出问题了。")]),a._v(" "),e("p",[a._v("NPM分身：不同版本的情况下有大量的依赖可能被重复安装，这种场景在monorepo 多包场景下尤其明显，这也是"),e("code",[a._v("yarn workspace")]),a._v("经常被吐槽的点，另外扁平化的算法实现也相当复杂，改动成本很高")])])]),a._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v("项目中有packageA、packageB、packageC、packageD。packageA依赖packageX 1.0和packageY 1.0，packageB依赖packageX 2.0和packageY 2.0，packageC依赖packageX 1.0和packageY 2.0，packageD依赖packageX 2.0和packageY 1.0\n\n- package X => 1.0版本\n- package Y => 1.0版本\n\n- package A\n- package B\n    - packageX 2.0\n    - packageY 2.0\n- package C\n    - packageY 2.0\n- package D\n    - packageX 2.0\n\npackageX 2.0和packageY 2.0被重复安装多次，从而造成 npm 和 yarn 的性能一些性能损失。\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br"),e("span",{staticClass:"line-number"},[a._v("5")]),e("br"),e("span",{staticClass:"line-number"},[a._v("6")]),e("br"),e("span",{staticClass:"line-number"},[a._v("7")]),e("br"),e("span",{staticClass:"line-number"},[a._v("8")]),e("br"),e("span",{staticClass:"line-number"},[a._v("9")]),e("br"),e("span",{staticClass:"line-number"},[a._v("10")]),e("br"),e("span",{staticClass:"line-number"},[a._v("11")]),e("br"),e("span",{staticClass:"line-number"},[a._v("12")]),e("br"),e("span",{staticClass:"line-number"},[a._v("13")]),e("br"),e("span",{staticClass:"line-number"},[a._v("14")]),e("br"),e("span",{staticClass:"line-number"},[a._v("15")]),e("br")])]),e("h2",{attrs:{id:"软链接和硬链接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#软链接和硬链接"}},[a._v("#")]),a._v(" 软链接和硬链接")]),a._v(" "),e("p",[a._v("软链接：类似于Windows的快捷方式，会创建新的文件和 inode，但是软链接文件inode指向源文件的 inode")]),a._v(" "),e("p",[a._v("硬链接：只能用于文件不能用于目录，不会创建额外 inode，它和源文件共用同一个 inode，修改源文件之后，硬链接中的文件内容也同时发生了变更")]),a._v(" "),e("ul",[e("li",[a._v("删除源文件不会影响硬链接文件的访问（因为inode还在）")]),a._v(" "),e("li",[a._v("删除源文件会影响软链接文件的访问（因为指向的inode已经不存在了）")]),a._v(" "),e("li",[a._v("硬链接不占用磁盘空间，软链接占用的空间只是存储路径所占用的极小空间")])]),a._v(" "),e("h2",{attrs:{id:"pnpm"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#pnpm"}},[a._v("#")]),a._v(" pnpm")]),a._v(" "),e("p",[a._v("pnpm 本质上就是一个包管理器，这一点跟 npm/yarn 没有区别，但它具有两个优势:")]),a._v(" "),e("ul",[e("li",[a._v("包安装速度极快；")]),a._v(" "),e("li",[a._v("磁盘空间利用非常高效。")])]),a._v(" "),e("p",[a._v("pnpm在安装依赖包时，不像npm和yarn那样将每个项目的依赖包存储到各自的node_modules中，而是将依赖包存储到系统的全局存储库中（通常在 ~/.pnpm-store 目录下）。当某个项目需要依赖包时，pnpm会在该项目的 node_modules 中创建一个符号链接（symlink）指向.pnpm全局存储库中的依赖包。")]),a._v(" "),e("p",[a._v("pnpm：网状 + 平铺的node_modules结构")]),a._v(" "),e("p",[a._v(".pnpm 目录之外的其实是我们在日常开发中实际引用的是依赖，但是它对于 pnpm 来说它是软链接，最终软链接实际引用的还是 .pnpm 中的真实依赖。解决“幽灵依赖”的问题，只有声明过的依赖才会以软链接的形式出现在 node_modules 目录中。在实际项目中引用的是软链接，软链接指向的是 .pnpm 的真实依赖，所以在日常开发中不会引用到未在 package.json 声明的包")]),a._v(" "),e("p",[e("code",[a._v(".pnpm")]),a._v(" (虚拟存储目录)以平铺的形式储存着所有的包，正常的包都可以在这种命名模式的文件夹中被找到，该目录通过"),e("code",[a._v("<package-name>@<version>")]),a._v("来实现相同模块不同版本之间隔离和复用，由于"),e("strong",[a._v("它只会根据项目中的依赖生成")]),a._v("，并不存在提升")]),a._v(" "),e("p",[a._v("使用 pnpm 对项目安装依赖的时候，如果某个依赖在 store目录中存在了话，那么就会直接从 store 目录里面去 hard-link硬链接减少了文件下载的数量，从而提升了下载和响应速度。避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。接着在项目中则通过"),e("code",[a._v("symbolic link")]),a._v("软链接到"),e("code",[a._v(".pnpm/node_modules")]),a._v("目录中")]),a._v(" "),e("p",[e("img",{attrs:{src:n(460),alt:"image-20230401160125390"}})]),a._v(" "),e("h2",{attrs:{id:"package-lock-json文件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#package-lock-json文件"}},[a._v("#")]),a._v(" package-lock.json文件")]),a._v(" "),e("img",{staticStyle:{zoom:"150%"},attrs:{src:n(461),alt:"image-20230321084803087"}}),a._v(" "),e("ul",[e("li",[a._v("-S是--save的简写表示开发和部署上线都会用到 dependencies属性")]),a._v(" "),e("li",[a._v("-D是--save-dev的简写表示开发用到但部署上线不会用到 devDependencies属性 如babel webpack")]),a._v(" "),e("li",[a._v("peerDependencies属性 表示对等依赖 依赖一个包必须以另一个宿主为前提 比如element-plus 依赖Vue3")]),a._v(" "),e("li",[a._v("版本依赖管理 ^x.y.z表示x保持不变yz安装最新版本     ~x.y.z表示xy保持不变z安装最新版本")])]),a._v(" "),e("h2",{attrs:{id:"npx"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npx"}},[a._v("#")]),a._v(" npx")]),a._v(" "),e("p",[a._v("npx是一个工具，npm v5.2.0引入的一条命令（npx），一个npm包执行器，旨在提高从npm注册表使用软件包的体验")]),a._v(" "),e("p",[e("strong",[a._v("调用项目安装的模块")])]),a._v(" "),e("p",[a._v("npx 的原理就是运行的时候，会到"),e("code",[a._v("node_modules/.bin")]),a._v("路径和环境变量"),e("code",[a._v("$PATH")]),a._v("里面，检查命令是否存在。")]),a._v(" "),e("p",[a._v("由于 npx 会检查环境变量"),e("code",[a._v("$PATH")]),a._v("，所以系统命令也可以调用。")]),a._v(" "),e("p",[a._v("一般来说，调用 Mocha ，只能在项目脚本和 package.json 的"),e("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2016/10/npm_scripts.html",target:"_blank",rel:"noopener noreferrer"}},[e("code",[a._v("scripts")]),e("OutboundLink")],1),a._v("字段里面， 如果想在命令行下调用，必须像下面这样。")]),a._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# 项目的根目录下执行")]),a._v("\nnode-modules/.bin/mocha "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--version")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("# npx 就是想解决这个问题，让项目内部安装的模块用起来更方便，只要像下面这样调用就行了。")]),a._v("\nnpx mocha "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("--version")]),a._v("\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br"),e("span",{staticClass:"line-number"},[a._v("3")]),e("br"),e("span",{staticClass:"line-number"},[a._v("4")]),e("br")])]),e("p",[e("strong",[a._v("避免全局安装模块")])]),a._v(" "),e("p",[a._v("除了调用项目内部模块，npx 还能避免全局安装的模块。比如，"),e("code",[a._v("create-react-app")]),a._v("这个模块是全局安装，npx 可以运行它，而且不进行全局安装。")]),a._v(" "),e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[a._v("npx create-react-app my-react-app\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br")])]),e("p",[a._v("上面代码运行时，npx 将"),e("code",[a._v("create-react-app")]),a._v("下载到一个临时目录，使用以后再删除。所以，以后再次执行上面的命令，会重新下载"),e("code",[a._v("create-react-app")]),a._v("。")]),a._v(" "),e("p",[a._v("利用 npx 可以下载模块这个特点，可以指定某个版本的 Node 运行脚本。它的窍门就是使用 npm 的 node 模块")]),a._v(" "),e("blockquote",[e("div",{staticClass:"language-bash line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[a._v("npx node@0.12.8 "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[a._v("-v")]),a._v("\nv0.12.8\n")])]),a._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[a._v("1")]),e("br"),e("span",{staticClass:"line-number"},[a._v("2")]),e("br")])])]),a._v(" "),e("p",[a._v("上面命令会使用 0.12.8 版本的 Node 执行脚本。原理是从 npm 下载这个版本的 node，使用后再删掉。")]),a._v(" "),e("h2",{attrs:{id:"npmrc"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npmrc"}},[a._v("#")]),a._v(" .npmrc")]),a._v(" "),e("p",[a._v("npmrc是npm的配置文件，它位于用户主目录下的"),e("code",[a._v(".npmrc")]),a._v("文件或项目根目录下的"),e("code",[a._v(".npmrc")]),a._v("文件。npmrc文件由一系列键值对组成，用于配置npm在执行命令时的行为和参数")]),a._v(" "),e("p",[a._v("定义镜像源，管理依赖存储路径、保存开发依赖...")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7262256657131651132#heading-11",target:"_blank",rel:"noopener noreferrer"}},[a._v("深入了解npmrc：使用与配置指南 - 掘金 (juejin.cn)"),e("OutboundLink")],1)]),a._v(" "),e("h2",{attrs:{id:"npm-install-过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#npm-install-过程"}},[a._v("#")]),a._v(" npm install 过程")]),a._v(" "),e("p",[e("img",{attrs:{src:n(462),alt:"image-20230321085306628"}}),a._v("\n图片勘误: 压缩到node_modules改为解压到node_modules")]),a._v(" "),e("ol",[e("li",[a._v("解析package.json文件：根据项目中的package.json文件确定需要安装的依赖包及其版本。")]),a._v(" "),e("li",[a._v("下载依赖包：从NPM仓库下载需要安装的依赖包及其相关依赖包。")]),a._v(" "),e("li",[a._v("安装依赖包：将下载下来的依赖包解压缩，并将其复制到项目目录的node_modules文件夹下。")]),a._v(" "),e("li",[a._v("执行依赖包的安装脚本：如果依赖包中包含installer或preinstall脚本，那么在安装后会被执行。")]),a._v(" "),e("li",[a._v("生成依赖关系树：根据依赖包的依赖关系，生成依赖关系树。")]),a._v(" "),e("li",[a._v("保存依赖信息：将安装的依赖包及其版本号保存到package-lock.json或yarn.lock文件中，以便在下次安装时使用。")])]),a._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/7053340250210795557#heading-0",target:"_blank",rel:"noopener noreferrer"}},[a._v("pnpm快到碗里来！ - 掘金 (juejin.cn)"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.freecodecamp.org/chinese/news/what-is-npm-a-node-package-manager-tutorial-for-beginners/",target:"_blank",rel:"noopener noreferrer"}},[a._v("什么是 npm —— 写给初学者的编程教程 (freecodecamp.org)"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/254794d5e741",target:"_blank",rel:"noopener noreferrer"}},[a._v("npm和yarn的区别，我们该如何选择? - 简书 (jianshu.com)"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://www.ruanyifeng.com/blog/2019/02/npx.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("npx 使用教程 - 阮一峰的网络日志 (ruanyifeng.com)"),e("OutboundLink")],1)]),a._v(" "),e("p",[e("a",{attrs:{href:"https://juejin.cn/post/6983522411647860766",target:"_blank",rel:"noopener noreferrer"}},[a._v("npm中，你不了解的.npmrc文件 - 掘金 (juejin.cn)"),e("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=r.exports}}]);