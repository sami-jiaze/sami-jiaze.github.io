(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{467:function(v,_,t){"use strict";t.r(_);var r=t(2),a=Object(r.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"tcp-ip协议族"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip协议族"}},[v._v("#")]),v._v(" TCP/IP协议族")]),v._v(" "),_("p",[v._v("（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的"),_("strong",[v._v("协议簇")])]),v._v(" "),_("p",[v._v("TCP/IP协议"),_("strong",[v._v("主要")]),v._v("由网络层的IP协议 和 传输层的TCP协议组成 。")]),v._v(" "),_("h2",{attrs:{id:"tcp-ip的分层-四层"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp-ip的分层-四层"}},[v._v("#")]),v._v(" TCP/IP的分层（四层）")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230104142517500.png",alt:"image-20230104142517500"}})]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105091840901.png",alt:"image-20230105091840901"}})]),v._v(" "),_("h2",{attrs:{id:"应用层-application-layer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#应用层-application-layer"}},[v._v("#")]),v._v(" 应用层(Application Layer)")]),v._v(" "),_("p",[v._v("应用层决定了向用户提供应用服务时通信的活动。TCP/IP 协议族内预存了各类通用的应用服务。比如，FTP（FileTransfer\nProtocol，文件传输协议）和 DNS（Domain Name System，域名系统）服务就是其中两类。HTTP 协议也处于该层。")]),v._v(" "),_("h2",{attrs:{id:"传输层-transport-layer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#传输层-transport-layer"}},[v._v("#")]),v._v(" 传输层(Transport Layer)")]),v._v(" "),_("p",[v._v("传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两个性质不同的协议：TCP（Transmission ControlProtocol，传输控制协议）和UDP（User Data Protocol，用户数据报协议）。")]),v._v(" "),_("h2",{attrs:{id:"网络层-network-layer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#网络层-network-layer"}},[v._v("#")]),v._v(" 网络层(Network Layer)")]),v._v(" "),_("p",[v._v("网络层用来处理在网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据包传送给对方。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。")]),v._v(" "),_("h2",{attrs:{id:"链路层-link-layer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#链路层-link-layer"}},[v._v("#")]),v._v(" 链路层(Link Layer)")]),v._v(" "),_("p",[v._v("用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（Network Interface Card，网络适配器，即网卡），及光纤等物理可见部分（还包括连接器等一切传输媒介）。硬件上的范畴均在链路层的作用范围之内。")]),v._v(" "),_("h2",{attrs:{id:"tcp"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp"}},[v._v("#")]),v._v(" TCP")]),v._v(" "),_("p",[v._v("TCP是一种面向连接的、可靠的、基于字节流的传输层通信协议，它会保证数据不丢包、不乱序。")]),v._v(" "),_("p",[v._v("HTTP是建立在TCP之上的，当你建立起TCP连接之后，在上面传输的数据用的是HTTP协议。")]),v._v(" "),_("p",[v._v("TCP用序列号和确认应答号（ack）来保证可靠传输。在TCP传送一个数据包时，它会把这个数据包放入重发队列中，同时启动计时器，如果收到了关于这个包的确认信息，便将此数据包从队列中删除，如果在计时器超时的时候仍然没有收到确认信息，则需要重新发送该数据包。另外，TCP通过数据分段中的序列号来 保证所有传输的数据可以按照正常的顺序进行重组，从而保障数据传输的完整")]),v._v(" "),_("h2",{attrs:{id:"tcp报文段"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp报文段"}},[v._v("#")]),v._v(" TCP报文段")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105091248535.png",alt:"image-20230105091248535"}})]),v._v(" "),_("ul",[_("li",[v._v("源端口：标识源端应用进程，即发送TCP分组的进程端口号。")]),v._v(" "),_("li",[v._v("目的端口：标识目的端应用进程，即需要接收分组数据的进程端口号。")]),v._v(" "),_("li",[v._v("序号（seq）：在SYN标志未置1时，该字段指示了用户数据区中的第一个字节的序列号；在SYN标志置1时，该字段指示的是初始发送的序列号。")]),v._v(" "),_("li",[v._v("确认号（ack）：用来确认本端TCP实体已经接收到的数据，其值表示期待对端发送的下一个字节的序号，实际上告诉对方，这个序号减1以前的字节已经正确接收。例如发送确认号为1001，则表示前1000个字节已经被确认接收了。")]),v._v(" "),_("li",[v._v("数据偏移：表示以 32bit为单位的TCP分组头的总长度，用于确定用户数据区的起始位置。这个字段实际上是指出了TCP报文段的首部长度。")]),v._v(" "),_("li",[v._v("RST：连接复位，重新连接")]),v._v(" "),_("li",[v._v("SYN：同步序号，"),_("strong",[v._v("当SYN置1时，表示建立连接")]),v._v("，分组将发送seq为初始序列号（其值一般随机）")]),v._v(" "),_("li",[v._v("终止标志位FIN：结束标志，表示关闭连接，当该字段置1时，表示分组将要关闭连接")]),v._v(" "),_("li",[v._v("ACK：确认号有效的标志，置1时表示确认号有效。")]),v._v(" "),_("li",[v._v("URG：紧急指针有效的标志，置1时表示紧急指针有效")]),v._v(" "),_("li",[v._v("推送标志位PSH：接收方的TCP收到该标志位为1的报文段会尽快上交应用进程，而不必等到接收缓存都填满后再向上交付")]),v._v(" "),_("li",[v._v("窗口： 占16比特，以字节为单位。指出发送本报文段的一方的接收窗。")])]),v._v(" "),_("p",[v._v("注意区别ACK确认号标志位和确认号ack。")]),v._v(" "),_("h2",{attrs:{id:"tcp建立连接的过程-三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp建立连接的过程-三次握手"}},[v._v("#")]),v._v(" TCP建立连接的过程（三次握手）")]),v._v(" "),_("p",[v._v("TCP 建立连接的过程叫做"),_("strong",[v._v("握手")]),v._v("，握手需要在客户和服务器之间交换三个TCP 报文段，称之为"),_("strong",[v._v("三报文握手")])]),v._v(" "),_("p",[v._v("三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息")]),v._v(" "),_("ul",[_("li",[v._v("主动发起TCP连接建立称为"),_("strong",[v._v("TCP客户")]),v._v("(client)。")]),v._v(" "),_("li",[v._v("被动等待TCP连接建立的应用进程称为"),_("strong",[v._v("TCP服务器")]),v._v("(server)。")])]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105093712483.png",alt:"image-20230105093712483"}})]),v._v(" "),_("p",[_("strong",[v._v("一开始，TCP服务器进程首先创建传输控制块，用来存储TCP连接中的一些重要信息。")]),v._v(" 例如TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针，当前的发送和接收序号等。之后就准备接受TCP客户进程的连接请求， 此时TCP服务器进程就要进入监听状态等待TCP客户进程的连接请求。TCP客户进程也是首先创建传输控制块")]),v._v(" "),_("p",[_("strong",[v._v("第一次握手")]),v._v("：")]),v._v(" "),_("p",[v._v("客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号（ISN），首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗掉一个序号。")]),v._v(" "),_("p",[_("strong",[v._v("第二次握手：")])]),v._v(" "),_("p",[v._v("服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号（ISN）。同时会把客户端的 ISN + 1 作为ack 的值，表示自己已经收到了客户端的 SYN。在确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y")]),v._v(" "),_("p",[_("strong",[v._v("第三次握手：")])]),v._v(" "),_("p",[v._v("客户端收到 SYN 报文之后，会发送一个 ACK 报文，把服务器的 ISN + 1 作为 ack 的值，表示已经收到了服务端的 SYN 报文，确认报文段ACK=1，确认号ack=y+1，序号seq=x+1，"),_("strong",[v._v("ACK报文段可以携带数据，不携带数据则不消耗序号")]),v._v("。服务器收到应答后连接建立成功")]),v._v(" "),_("h2",{attrs:{id:"为什么需要三次握手-两次握手可以吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要三次握手-两次握手可以吗"}},[v._v("#")]),v._v(" 为什么需要三次握手，两次握手可以吗")]),v._v(" "),_("p",[v._v("防止失效的请求报文段被服务器接收，建立一个无效的连接浪费资源。")]),v._v(" "),_("p",[v._v("谢希仁版《计算机网络》中的例子：“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”")]),v._v(" "),_("h2",{attrs:{id:"syn泛洪-syn-flood-攻击"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#syn泛洪-syn-flood-攻击"}},[v._v("#")]),v._v(" SYN泛洪（SYN flood）攻击")]),v._v(" "),_("p",[v._v("SYN攻击利用的是TCP的三次握手机制，大量的握手请求涌向TCP服务端，而它们只发出SYN报文而不以ACK响应结束握手，服务端就要为这每一个请求都维持约一分多钟的连接去等待ACK，也就形成所谓的“半连接”。维护这些半连接是需要消耗很多服务器的网络连接资源的。如果短时间内这些资源几乎都被半连接占满，那么正常的业务请求在这期间就得不到服务，处于等待状态。")]),v._v(" "),_("p",[v._v("更进一步的，如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这就形成了DoS（Denial of Service拒绝服务）攻击。这种攻击方式就称为SYN泛洪（SYN flood）攻击")]),v._v(" "),_("p",[_("strong",[v._v("防范措施")])]),v._v(" "),_("p",[v._v("如降低SYN timeout时间，使得主机尽快释放半连接的占用；又比如采用SYN cookie设置，如果短时间内连续收到某个IP的重复SYN请求，则认为受到了该IP的攻击，丢弃来自该IP的后续请求报文")]),v._v(" "),_("h2",{attrs:{id:"tcp拆除连接的过程-四次挥手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp拆除连接的过程-四次挥手"}},[v._v("#")]),v._v(" TCP拆除连接的过程（四次挥手）")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105101013923.png",alt:"image-20230105101013923"}})]),v._v(" "),_("p",[_("strong",[v._v("第一次挥手：")])]),v._v(" "),_("p",[v._v("客户端不再有数据发送给服务器，向服务器发送FIN报文表示想要关闭连接，报文中会指定一个序列号。发出连接释放报文段（FIN=1，序号seq=u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。")]),v._v(" "),_("p",[_("strong",[v._v("第二次挥手：")])]),v._v(" "),_("p",[v._v("服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了")]),v._v(" "),_("p",[v._v("但是，此时"),_("strong",[v._v("服务器可能还有部分数据没有回传给客户端，服务器还要向客户端发送一部分数据才能关闭连接。所以服务器不会立马同意关闭连接，而是先发送表示确认信息的ACK报文")]),v._v("，TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态，所以服务端仍旧可以发送数据给客户端")]),v._v(" "),_("p",[_("strong",[v._v("第三次挥手：")])]),v._v(" "),_("p",[v._v("在服务器端完成向客户端传送最后的数据后，此时不再有数据需要传输了。那么服务器也准备关闭连接，所以向客户端发送表示关闭连接的FIN报文")]),v._v(" "),_("p",[_("strong",[v._v("第四次挥手：")])]),v._v(" "),_("p",[v._v("客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。")]),v._v(" "),_("p",[v._v("客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭（服务器没有收到应答超时重传）")]),v._v(" "),_("h2",{attrs:{id:"tcp重传机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp重传机制"}},[v._v("#")]),v._v(" TCP重传机制")]),v._v(" "),_("p",[v._v("发出去的请求包在规定时间内没有收到ACK，不管是请求包丢失，ACK包丢失，还是网络延迟都会触发重传机制")]),v._v(" "),_("p",[_("strong",[v._v("超时重传")])]),v._v(" "),_("p",[v._v("在请求包发出去的时候，开启一个计时器，当计时器达到时间之后，没有收到ACK，则就进行重发请求的操作，一直重发直到达到重发上限次数或者收到ACK。")]),v._v(" "),_("p",[_("strong",[v._v("RTT")]),v._v("（Round-Trip Time 往返时延）"),_("strong",[v._v("数据从网络一端传送到另一端所需的时间")]),v._v("，也就是包的往返时间。")]),v._v(" "),_("p",[v._v("超时重传时间是以 "),_("strong",[v._v("RTO")]),v._v("（Retransmission Timeout 超时重传时间）表示。")]),v._v(" "),_("p",[v._v("超时重传时间 RTO 的值应该略大于报文往返 RTT 的值。实际上报文往返 RTT 的值是经常变化的，因为我们的网络也是时常变化的。也就因为报文往返 RTT 的值 是经常波动变化的，所以超时重传时间 RTO 的值应该是一个"),_("strong",[v._v("动态变化的值")]),v._v("。")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105224211679.png",alt:"image-20230105224211679"}})]),v._v(" "),_("p",[v._v("如果超时重发的数据，再次超时的时候，又需要重传的时候，TCP 的策略是"),_("strong",[v._v("超时间隔加倍。")])]),v._v(" "),_("p",[v._v("也就是每当遇到一次超时重传的时候，都会将下一次超时时间间隔设为先前值的两倍。两次超时，就说明网络环境差，不宜频繁反复发送。")]),v._v(" "),_("p",[_("strong",[v._v("快速重传")])]),v._v(" "),_("p",[v._v("接收端如果没有收到期望的数据，而收到后续乱序的包，也给客户端回复 ACK，只不过是重复的 ACK，回复相同的ACK三次以后触发快速重传")]),v._v(" "),_("p",[v._v("例子：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6")]),v._v(" "),_("p",[v._v("快速重传不用考虑超时问题但存在该重传多少个包的问题，上述案例发送端既可以重传2，也可以重传2，3，4，5，因为发送端并不清楚这连续的3个ack(2)是谁传回来的，也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据")]),v._v(" "),_("p",[_("strong",[v._v("SACK")])]),v._v(" "),_("p",[v._v("SACK（Selective Acknowledgment），在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了。")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105222852966.png",alt:"image-20230105222852966"}})]),v._v(" "),_("p",[_("strong",[v._v("DSACK")])]),v._v(" "),_("p",[v._v("Duplicate SACK")]),v._v(" "),_("p",[v._v("DSACK，即重复 SACK，这个机制是在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了。DSACK 的目的是帮助发送方判断，是否发生了包失序、ACK 丢失、包重复或伪重传。让 TCP 可以更好的做网络流控")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105223240058.png",alt:"image-20230105223240058"}})]),v._v(" "),_("h2",{attrs:{id:"tcp拥塞控制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#tcp拥塞控制"}},[v._v("#")]),v._v(" TCP拥塞控制")]),v._v(" "),_("p",[v._v("在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做"),_("strong",[v._v("网络拥塞")])]),v._v(" "),_("p",[v._v("在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大")]),v._v(" "),_("p",[v._v("当网络发送拥塞时，TCP 会降低发送的数据量。这就是"),_("strong",[v._v("拥塞控制")]),v._v("，控制的目的就是避免「发送方」的数据填满整个网络。")]),v._v(" "),_("p",[v._v("为了在「发送方」调节所要发送数据的量，定义了一个叫做「"),_("strong",[v._v("拥塞窗口")]),v._v("」的概念")]),v._v(" "),_("p",[_("strong",[v._v("拥塞窗口 cwnd")]),v._v("是发送方维护的一个 的状态变量，它会根据"),_("strong",[v._v("网络的拥塞程度动态变化的")]),v._v("。")]),v._v(" "),_("p",[v._v("TCP的拥塞控制机制主要是以下四种机制：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("慢启动（慢开始）")])])]),v._v(" "),_("p",[v._v("当发送方每收到一个 ACK，就拥塞窗口 cwnd 的大小就会加 1。")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105230346428.png",alt:"image-20230105230346428"}})]),v._v(" "),_("p",[v._v("有一个叫慢启动门限 "),_("code",[v._v("ssthresh")]),v._v(" （slow start threshold）状态变量。")]),v._v(" "),_("ol",[_("li",[v._v("当 "),_("code",[v._v("cwnd")]),v._v(" < "),_("code",[v._v("ssthresh")]),v._v(" 时，使用慢启动算法。")]),v._v(" "),_("li",[v._v("当 "),_("code",[v._v("cnwd = ssthresh")]),v._v("时，既可使用慢开始算法，也可以使用拥塞避免算法")]),v._v(" "),_("li",[v._v("当 "),_("code",[v._v("cwnd")]),v._v(" > "),_("code",[v._v("ssthresh")]),v._v(" 时，使用拥塞避免算法。")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("拥塞避免")])])]),v._v(" "),_("p",[v._v("拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞")]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105232520734.png",alt:"image-20230105232520734"}})]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("采用快速重传")])])]),v._v(" "),_("p",[v._v("采用快重传算法可以让发送方尽早知道发生了个别报文段的丢失。而不是等超时重传计时器超时再重传。")]),v._v(" "),_("p",[v._v("快速重传")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("cwnd = cwnd/2")]),v._v(" ，也就是设置为原来的一半")]),v._v(" "),_("li",[_("code",[v._v("ssthresh = cwnd")]),v._v(";")])]),v._v(" "),_("p",[v._v("超时重传")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("ssthresh")]),v._v(" 设为 "),_("code",[v._v("cwnd/2")])]),v._v(" "),_("li",[_("code",[v._v("cwnd")]),v._v(" 重置为 "),_("code",[v._v("1")])])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("快速恢复")])])]),v._v(" "),_("p",[v._v("进入快速恢复之前，"),_("code",[v._v("cwnd")]),v._v(" 和 "),_("code",[v._v("ssthresh")]),v._v(" 已被更新了：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("cwnd = cwnd/2")]),v._v(" ，也就是设置为原来的一半;")]),v._v(" "),_("li",[_("code",[v._v("ssthresh = cwnd")]),v._v(";")])]),v._v(" "),_("p",[v._v("然后，进入快速恢复算法如下：")]),v._v(" "),_("ol",[_("li",[v._v("拥塞窗口 "),_("code",[v._v("cwnd = ssthresh + 3")]),v._v(" （ 3 的意思是确认有 3 个数据包被收到了）")]),v._v(" "),_("li",[v._v("重传丢失的数据包")]),v._v(" "),_("li",[v._v("如果再收到重复的 ACK，那么 cwnd 增加 1")]),v._v(" "),_("li",[v._v("如果收到新数据的 ACK 后，设置 cwnd 为 ssthresh，接着就进入了拥塞避免算法")])]),v._v(" "),_("p",[_("img",{attrs:{src:"E:%5CHTML,CSS,JavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CTCPIP.assets%5Cimage-20230105232202119.png",alt:"image-20230105232202119"}})]),v._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")]),v._v(" "),_("p",[_("strong",[v._v("《图解TCP/IP》")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://xiaolincoding.com/",target:"_blank",rel:"noopener noreferrer"}},[v._v("小林coding (xiaolincoding.com)"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("strong",[v._v("计算机网络微课堂（湖科大教书匠）")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/61987654",target:"_blank",rel:"noopener noreferrer"}},[v._v("关于TCP传输协议看这一篇就够了 - 知乎 (zhihu.com)"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/weixin_45863060/article/details/122152696",target:"_blank",rel:"noopener noreferrer"}},[v._v("(54条消息) TCP协议详解_独行的喵的博客-CSDN博客_tcp协议"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/430799766",target:"_blank",rel:"noopener noreferrer"}},[v._v("深入浅出TCP三次握手 （多图详解） - 知乎 (zhihu.com)"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/LOOKTOMMER/article/details/121243476?spm=1001.2014.3001.5501",target:"_blank",rel:"noopener noreferrer"}},[v._v("(54条消息) TCP三次握手详解_‍oOoOoOooOO的博客-CSDN博客_tcp三次握手详解"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/LOOKTOMMER/article/details/121307137",target:"_blank",rel:"noopener noreferrer"}},[v._v("(54条消息) TCP四次挥手详解_‍oOoOoOooOO的博客-CSDN博客_tcp四次挥手"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/-wenli/p/13080675.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("TCP重传机制 - -零 - 博客园 (cnblogs.com)"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/qq_41431406/article/details/97926927",target:"_blank",rel:"noopener noreferrer"}},[v._v("(37条消息) TCP的拥塞控制（详解）_一颗程序媛0915的博客-CSDN博客_tcp拥塞控制"),_("OutboundLink")],1)]),v._v(" "),_("p",[_("a",{attrs:{href:"https://www.cnblogs.com/-wenli/p/13089310.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("TCP窗口机制与流量控制 - -零 - 博客园 (cnblogs.com)"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=a.exports}}]);