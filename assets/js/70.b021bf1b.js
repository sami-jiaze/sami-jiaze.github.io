(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{667:function(t,v,_){"use strict";_.r(v);var a=_(2),s=Object(a.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("总览")]),t._v(" "),v("p",[t._v("编译型与解释型、弱类型与强类型、动态语言与静态语言、动态类型与静态类型")])]),t._v(" "),v("h2",{attrs:{id:"编译型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编译型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("编译型语言")])]),t._v(" "),v("p",[t._v("需通过编译器（compiler）将源代码编译成机器码，之后才能执行的语言。一般需经过编译（compile）、链接（linker）这两个步骤。编译是把源代码编译成机器码，链接是把各个模块的机器码和依赖库串连起来生成可执行文件。")]),t._v(" "),v("p",[t._v("优点：把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。可以脱离语言环境独立运行。由于要经历完整编译过程，因此在程序有任何语法错误都能在编译期被发现，大大降低程序的运行错误。")]),t._v(" "),v("p",[t._v("缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。")]),t._v(" "),v("p",[t._v("代表语言：C、C++、Pascal、Object-C以及最近很火的苹果新语言swift")]),t._v(" "),v("h2",{attrs:{id:"解释型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解释型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("解释型语言")])]),t._v(" "),v("p",[t._v("解释性语言的程序不需要编译，相比编译型语言省了道工序，只有在执行到对应的语句时才会将源代码一行一行的解释成机器语言")]),t._v(" "),v("p",[t._v("优点：有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。")]),t._v(" "),v("p",[t._v("缺点：每次运行的时候都要解释一遍，性能上不如编译型语言。")]),t._v(" "),v("p",[t._v("代表语言：JavaScript、Python、Erlang、PHP、Perl、Ruby")]),t._v(" "),v("p",[v("strong",[t._v("编译器")]),t._v("是把源程序的每一条语句都编译成机器语言,并保存成二进制文件,这样运行时计算机可以直接以机器语言来运行此程序,速度很快;")]),t._v(" "),v("p",[t._v("而"),v("strong",[t._v("解释器")]),t._v("则是只在执行程序时,才一条一条的解释成机器语言给计算机来执行,所以运行速度是不如编译后的程序运行的快的.")]),t._v(" "),v("p",[t._v("这是因为计算机不能直接认识并执行我们写的语句,它只能认识机器语言(是二进制的形式)")]),t._v(" "),v("h2",{attrs:{id:"弱类型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#弱类型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("弱类型语言")])]),t._v(" "),v("p",[t._v("数据类型可以被忽略的语言。它与强类型定义语言相反， 一个变量可以赋不同数据类型的值。一旦给一个整型变量a赋一个字符串值，那么a就变成字符类型")]),t._v(" "),v("h2",{attrs:{id:"强类型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#强类型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("强类型语言")])]),t._v(" "),v("p",[t._v("要求变量的使用要严格符合定义，所有变量都必须先定义后使用。一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了")]),t._v(" "),v("h2",{attrs:{id:"动态类型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态类型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("动态类型语言")])]),t._v(" "),v("p",[t._v("动态类型语言是指在运行期间才去做"),v("strong",[t._v("数据类型")]),t._v("检查的语言，说的是数据类型，"),v("strong",[t._v("动态语言")]),t._v("说的是运行是改变结构，说的是代码结构。")]),t._v(" "),v("p",[t._v("动态类型语言的数据类型不是在编译阶段决定的，而是把类型绑定延后到了运行阶段。")]),t._v(" "),v("p",[t._v("主要语言：Python、Ruby、Erlang、JavaScript、swift、PHP、Perl。")]),t._v(" "),v("h2",{attrs:{id:"静态类型语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态类型语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("静态类型语言")])]),t._v(" "),v("p",[t._v("静态语言的数据类型是在编译其间确定的或者说运行之前确定的，编写代码的时候要明确确定变量的数据类型。")]),t._v(" "),v("p",[t._v("主要语言：C、C++、C#、Java、Object-C。")]),t._v(" "),v("h2",{attrs:{id:"动态语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#动态语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("动态语言")])]),t._v(" "),v("p",[t._v("是一类在运行时可以改变其"),v("strong",[t._v("结构")]),t._v("的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构。")]),t._v(" "),v("p",[t._v("主要动态语言：Object-C、C#、JavaScript、PHP、Python、Erlang。")]),t._v(" "),v("h2",{attrs:{id:"静态语言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#静态语言"}},[t._v("#")]),t._v(" "),v("strong",[t._v("静态语言")])]),t._v(" "),v("p",[t._v("与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++。")])])}),[],!1,null,null,null);v.default=s.exports}}]);