(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{465:function(t,s,v){t.exports=v.p+"assets/img/image-20230130093718591.4dc963b3.png"},466:function(t,s,v){t.exports=v.p+"assets/img/image-20230130094642773.35d88295.png"},467:function(t,s,v){t.exports=v.p+"assets/img/1418466-20180812200309137-101174843.4405c74e.png"},468:function(t,s,v){t.exports=v.p+"assets/img/image-20230109172428187.ea26a55f.png"},603:function(t,s,v){"use strict";v.r(s);var a=v(2),_=Object(a.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("总览")]),t._v(" "),s("p",[t._v("什么是HTTP，HTTP缓存，HTTTPS")])]),t._v(" "),s("h2",{attrs:{id:"什么是http"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是http"}},[t._v("#")]),t._v(" 什么是HTTP")]),t._v(" "),s("p",[t._v("HTTP是超文本传输协议，专门用来在"),s("strong",[t._v("两点之间传输数据")]),t._v("的约定和规范。不仅可用于浏览器至服务器，也可以使用在服务器至服务器")]),t._v(" "),s("p",[t._v("HTTP 协议是一个"),s("strong",[t._v("双向的应用层协议")]),t._v("。")]),t._v(" "),s("p",[t._v("我们在上网冲浪时，假设浏览器是请求方 A ，目标网站是应答方 B，数据虽然是在 A 和 B 之间传输，但允许中间有"),s("strong",[t._v("中转或接力")]),t._v("。")]),t._v(" "),s("p",[t._v("传递的过程中如果需要经过好多个中间人，这样的传输方式就从「A < --- > B」，变成了「A <-> N <-> M <-> B」。")]),t._v(" "),s("p",[t._v("而在 HTTP 里，需要中间人遵从 HTTP 协议")]),t._v(" "),s("h2",{attrs:{id:"http版本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http版本"}},[t._v("#")]),t._v(" HTTP版本")]),t._v(" "),s("ul",[s("li",[t._v("HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。")]),t._v(" "),s("li",[t._v("HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法")]),t._v(" "),s("li",[t._v("HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。")])]),t._v(" "),s("h2",{attrs:{id:"http常见字段"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http常见字段"}},[t._v("#")]),t._v(" HTTP常见字段")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("Host 字段")]),t._v("  客户端发送请求时，用来指定服务器的域名。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Content-Length 字段")]),t._v("  服务器在返回数据时会有 "),s("code",[t._v("Content-Length")]),t._v(" 字段，表明本次回应的数据长度。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Connection 字段")]),t._v("  最常用于客户端要求服务器使用「HTTP 长连接」机制，以便其他请求复用HTTP 长连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态，HTTP/1.1 版本的默认连接都是长连接，但为了兼容老版本的 HTTP，需要指定 "),s("code",[t._v("Connection")]),t._v(" 首部字段的值为 "),s("code",[t._v("Keep-Alive")]),t._v("。开启了 HTTP Keep-Alive 机制后， 连接就不会中断，而是保持连接。当客户端发送另一个请求时，它会使用同一个连接，一直持续到客户端或服务器端提出断开连接。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Content-Type 字段")]),t._v("  用于服务器回应时，告诉客户端，本次数据是什么格式。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Accept 字段")]),t._v("  客户端请求的时候，可以使用 "),s("code",[t._v("Accept")]),t._v(" 字段声明自己可以接受哪些数据格式。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Content-Encoding 字段")]),t._v("  说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("Accept-Encoding字段")]),t._v("  客户端在请求时，用 "),s("code",[t._v("Accept-Encoding")]),t._v(" 字段说明自己可以接受哪些压缩方法。")])])]),t._v(" "),s("h2",{attrs:{id:"解决粘包问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解决粘包问题"}},[t._v("#")]),t._v(" 解决粘包问题")]),t._v(" "),s("p",[t._v("HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题")]),t._v(" "),s("h2",{attrs:{id:"http请求方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http请求方法"}},[t._v("#")]),t._v(" HTTP请求方法")]),t._v(" "),s("p",[t._v("HTTP默认使用80端口，这个端口指的是服务端的端口，而客户端使用的端口是动态分配的。当我们没有指定端口访问时，浏览器会默认帮我们添加80端口。需要注意的是，HTTPS的默认端口为443，如果使用80端口访问HTTPS协议的服务器可能会被拒绝。")]),t._v(" "),s("p",[t._v("HTTP请求的方法：")]),t._v(" "),s("p",[s("img",{attrs:{src:v(465),alt:"image-20230130093718591"}})]),t._v(" "),s("p",[s("strong",[t._v("GET与POST")])]),t._v(" "),s("p",[t._v("“get”方法提交的数据会直接填充在请求报文的URL上，如“ https://www.baidu.com/s?ie=utf-8&f=8&rsv_bp=1 ”  “？”问号划分域名和get提交的参数，A=B中的A是参数名，B是参数值，多个参数之间用&进行分割，如果参数值是中文，则会转换成诸如%ab%12加密16进制码。一般来说，浏览器处理的URL最大限度长度为1024B（不同浏览器不一样），所以GET方法提交参数长度有限制。")]),t._v(" "),s("p",[t._v("​    “post”方法提交的数据会附在正文上，一般请求正文的长度是没有限制的，但表单中所能处理的长度一般为100k（不同协议不同浏览器不一样）,而且需要考虑下层报文的传输效率，不推荐过长。")]),t._v(" "),s("p",[t._v("​    所以GET方法可以用来传输一些可以公开的参数信息，解析也比较方便，如百度的搜索的关键词，而POST方法可以用来提交一个用户的敏感信息（如果不使用HTTPS加密，报文正文仍旧是明文，容易被人截获读取）")]),t._v(" "),s("h2",{attrs:{id:"http请求消息request"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http请求消息request"}},[t._v("#")]),t._v(" HTTP请求消息Request")]),t._v(" "),s("p",[t._v("客户端发送一个HTTP请求到服务器的请求消息包括以下格式")]),t._v(" "),s("p",[t._v("请求行（request line）、请求头部（header）、空行和请求数据四个部分组成。")]),t._v(" "),s("p",[s("img",{attrs:{src:v(466),alt:"image-20230130094642773"}})]),t._v(" "),s("h2",{attrs:{id:"http响应消息response"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http响应消息response"}},[t._v("#")]),t._v(" HTTP响应消息Response")]),t._v(" "),s("p",[t._v("一般情况下，服务器接收并处理客户端发过来的请求后会返回一个HTTP的响应消息。")]),t._v(" "),s("p",[t._v("HTTP响应也由四个部分组成，分别是：状态行、消息报头、空行和响应正文")]),t._v(" "),s("p",[s("img",{attrs:{src:v(467),alt:""}})]),t._v(" "),s("div",{staticClass:"language-html line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-html"}},[s("code",[t._v("HTTP/1.1 200 OK\nDate: Fri, 22 May 2009 06:07:21 GMT\nContent-Type: text/html; charset=UTF-8\n\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("head")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("head")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("\x3c!--body goes here--\x3e")]),t._v("\n      "),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("body")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token tag"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("</")]),t._v("html")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br")])]),s("p",[s("strong",[t._v("第一部分：状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。")])]),t._v(" "),s("p",[t._v("第一行为状态行，（HTTP/1.1）表明HTTP版本为1.1版本，状态码为200，状态消息为（ok）")]),t._v(" "),s("p",[s("strong",[t._v("第二部分：消息报头，用来说明客户端要使用的一些附加信息")])]),t._v(" "),s("p",[t._v("第二行和第三行为消息报头，\nDate:生成响应的日期和时间；Content-Type:指定了MIME类型的HTML(text/html),编码类型是UTF-8")]),t._v(" "),s("p",[s("strong",[t._v("第三部分：空行，消息报头后面的空行是必须的")])]),t._v(" "),s("p",[s("strong",[t._v("第四部分：响应正文，服务器返回给客户端的文本信息。")])]),t._v(" "),s("p",[t._v("空行后面的html部分为响应正文。")]),t._v(" "),s("h2",{attrs:{id:"常见的http状态码"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见的http状态码"}},[t._v("#")]),t._v(" 常见的HTTP状态码")]),t._v(" "),s("p",[s("img",{attrs:{src:v(468),alt:"image-20230109172428187"}})]),t._v(" "),s("p",[t._v("2xx 类状态码表示服务器"),s("strong",[t._v("成功")]),t._v("处理了客户端的请求")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("200 OK")]),t._v(" 是最常见的成功状态码，表示一切正常。如果是非 "),s("code",[t._v("HEAD")]),t._v(" 请求，服务器返回的响应头都会有 body 数据")]),t._v(" "),s("li",[t._v("**204 No Content ** 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。")]),t._v(" "),s("li",[t._v("**206 Partial Content ** 是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。")])]),t._v(" "),s("p",[t._v("3xx 类状态码表示客户端请求的资源发生了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是"),s("strong",[t._v("重定向")]),t._v("。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("301 Moved Permanently")]),t._v("  表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。")]),t._v(" "),s("li",[s("strong",[t._v("302 Found")]),t._v("  表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。")])]),t._v(" "),s("p",[t._v("301 和 302 都会在响应头里使用字段 "),s("code",[t._v("Location")]),t._v("，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("304 Not Modified")]),t._v("   不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。")])]),t._v(" "),s("p",[t._v("4xx 类状态码表示客户端发送的"),s("strong",[t._v("报文有误")]),t._v("，服务器无法处理，也就是错误码的含义。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("400 BadRequest")]),t._v("   表示客户端请求的报文有错误，但只是个笼统的错误")]),t._v(" "),s("li",[s("strong",[t._v("401 Unauthorized")]),t._v("    用户没有访问权限，需要进行身份认证")]),t._v(" "),s("li",[t._v("**403 Forbidden **   表示服务器禁止访问资源，并不是客户端的请求出错")]),t._v(" "),s("li",[s("strong",[t._v("404 Not Found")]),t._v("    当资源不存在时，出现此结果。")]),t._v(" "),s("li",[s("strong",[t._v("405 Method Not Allowed")]),t._v("   由于方法和资源组合不正确而出现此错误。 例如，您不能对一个实体集合使用 DELETE 或 PATCH。")])]),t._v(" "),s("p",[t._v("5xx 类状态码表示客户端请求报文正确，但是"),s("strong",[t._v("服务器处理时内部发生了错误")]),t._v("，属于服务器端的错误码。")]),t._v(" "),s("ul",[s("li",[s("strong",[t._v("501  Not Implemented")]),t._v("   表示客户端请求的功能还不支持。")]),t._v(" "),s("li",[s("strong",[t._v("502 Bad Gateway")]),t._v("  通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。")]),t._v(" "),s("li",[s("strong",[t._v("503 Service Unavailable")]),t._v("    表示服务器当前很忙，暂时无法响应客户端")])]),t._v(" "),s("h2",{attrs:{id:"http缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http缓存"}},[t._v("#")]),t._v(" HTTP缓存")]),t._v(" "),s("p",[t._v("对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都"),s("strong",[t._v("缓存在本地")]),t._v("，HTTP 缓存有两种实现方式，分别是"),s("strong",[t._v("强制缓存和协商缓存")])]),t._v(" "),s("h2",{attrs:{id:"强制缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[t._v("#")]),t._v(" "),s("strong",[t._v("强制缓存")])]),t._v(" "),s("p",[t._v("强缓存指的是只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。")]),t._v(" "),s("p",[s("img",{attrs:{src:"E:%5CHTMLCSSJavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CHTTP.assets%5Cimage-20230324102557351.png",alt:"image-20230324102557351"}})]),t._v(" "),s("p",[t._v("强缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的，它们都用来表示资源在客户端缓存的有效期：")]),t._v(" "),s("ul",[s("li",[s("code",[t._v("Cache-Control")]),t._v("， 是一个相对时间；")]),t._v(" "),s("li",[s("code",[t._v("Expires")]),t._v("，是一个绝对时间；")])]),t._v(" "),s("p",[t._v("如果 HTTP 响应头部同时有 Cache-Control 和 Expires 字段的话，"),s("strong",[t._v("Cache-Control 的优先级高于 Expires")]),t._v(" 。")]),t._v(" "),s("p",[s("strong",[t._v("Expires")]),t._v("即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样: 表示资源在"),s("code",[t._v("2019年11月22号8点41分")]),t._v("过期，过期了就得向服务端发请求。")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Expires: Wed, 22 Nov 2019 08:41:00 GMT\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("但潜藏了一个问题，那就是"),s("strong",[t._v("服务器的时间和浏览器的时间可能并不一致")]),t._v("，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的"),s("code",[t._v("HTTP1.1")]),t._v("版本中被抛弃了")]),t._v(" "),s("p",[t._v("Cache-control 选项更多一些，设置更加精细，所以建议使用 Cache-Control 来实现强缓存。具体的实现流程如下：")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；")])]),t._v(" "),s("li",[s("p",[t._v("浏览器再次请求访问服务器中的该资源时，会先"),s("strong",[t._v("通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期")]),t._v("，如果没有，则使用该缓存，否则重新请求服务器；")])]),t._v(" "),s("li",[s("p",[t._v("服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control")]),t._v(" "),s("div",{staticClass:"language- line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("Cache-Control:max-age=3600\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br")])]),s("p",[t._v("代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。")]),t._v(" "),s("p",[t._v("它其实可以组合非常多的指令，完成更多场景的缓存判断:")]),t._v(" "),s("p",[s("strong",[t._v("public")]),t._v(": 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的"),s("code",[t._v("代理服务器")]),t._v("最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。")]),t._v(" "),s("p",[s("strong",[t._v("private")]),t._v("： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。")]),t._v(" "),s("p",[s("strong",[t._v("no-store")]),t._v("：非常粗暴，"),s("strong",[t._v("不进行任何形式的缓存")]),t._v("。")]),t._v(" "),s("p",[s("strong",[t._v("s-maxage")]),t._v("：这和"),s("code",[t._v("max-age")]),t._v("长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。")]),t._v(" "),s("p",[s("strong",[t._v("no-cache")]),t._v(": 跳过当前的强缓存，发送HTTP请求，即直接进入"),s("code",[t._v("协商缓存阶段")]),t._v("。")])])]),t._v(" "),s("h2",{attrs:{id:"协商缓存"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[t._v("#")]),t._v(" 协商缓存")]),t._v(" "),s("p",[t._v("你可能会看到过某些请求的响应码是 "),s("code",[t._v("304")]),t._v("，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。"),s("strong",[t._v("协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"E:%5CHTMLCSSJavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CHTTP.assets%5Cimage-20230324103500627.png",alt:"image-20230324103500627"}})]),t._v(" "),s("p",[t._v("协商缓存可以基于两种头部来实现。")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("请求头部中的 "),s("code",[t._v("If-Modified-Since")]),t._v(" 字段与响应头部中的 "),s("code",[t._v("Last-Modified")]),t._v(" 字段实现")]),t._v(" "),s("p",[t._v("响应头部中的 "),s("code",[t._v("Last-Modified")]),t._v("：标示这个响应资源的最后修改时间；")]),t._v(" "),s("p",[t._v("请求头部中的 "),s("code",[t._v("If-Modified-Since")]),t._v("：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。")])]),t._v(" "),s("li",[s("p",[t._v("请求头部中的 "),s("code",[t._v("If-None-Match")]),t._v(" 字段与响应头部中的 "),s("code",[t._v("ETag")]),t._v(" 字段")]),t._v(" "),s("p",[t._v("响应头部中 "),s("code",[t._v("Etag")]),t._v("：唯一标识响应资源；当浏览器再次请求访问服务器中的该资源时，首先会先检查强制缓存是否过期如果没有过期，则直接使用本地缓存；如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 ETag 唯一标识")]),t._v(" "),s("p",[t._v("请求头部中的 "),s("code",[t._v("If-None-Match")]),t._v("：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。")])])]),t._v(" "),s("p",[t._v("第一种实现方式是基于时间实现的，第二种实现方式是基于一个唯一标识实现的，相对来说后者可以更加准确地判断文件内容是否被修改，避免由于时间篡改导致的不可靠问题。")]),t._v(" "),s("p",[t._v("如果在第一次请求资源的时候，服务端返回的 HTTP 响应头部同时有 Etag 和 Last-Modified 字段，那么客户端再下一次请求的时候，如果带上了 ETag 和 Last-Modified 字段信息给服务端，"),s("strong",[t._v("这时 Etag 的优先级更高")]),t._v("，也就是服务端先会判断 Etag 是否变化了，如果 Etag 有变化就不用在判断 Last-Modified 了，如果 Etag 没有变化，然后再看 Last-Modified。")]),t._v(" "),s("p",[t._v("注意，"),s("strong",[t._v("协商缓存这两个字段都需要配合强制缓存中 Cache-Control 字段来使用，只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求")]),t._v("。")]),t._v(" "),s("p",[s("img",{attrs:{src:"E:%5CHTMLCSSJavaScript%5CmyBlog%5CJiaze-blog%5Cdocs%5C%E7%AC%94%E8%AE%B0%E6%95%B4%E7%90%86%5C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8E%E8%AE%A1%E7%BD%91%5CHTTP.assets%5Cimage-20230324104000202.png",alt:"image-20230324104000202"}})]),t._v(" "),s("h2",{attrs:{id:"http和https"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[t._v("#")]),t._v(" HTTP和HTTPS")]),t._v(" "),s("p",[t._v("HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，从而就诞生了HTTPS。简单来说，HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层，HTTP的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全。")]),t._v(" "),s("p",[t._v("HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。")]),t._v(" "),s("h2",{attrs:{id:"https特征"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#https特征"}},[t._v("#")]),t._v(" HTTPS特征")]),t._v(" "),s("ul",[s("li",[s("p",[s("strong",[t._v("信息加密")]),t._v("：交互信息无法被窃取")]),t._v(" "),s("p",[s("strong",[t._v("混合加密")]),t._v("的方式实现信息的"),s("strong",[t._v("机密性")]),t._v("，解决了窃听的风险。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("校验机制")]),t._v("：无法篡改通信内容，篡改了就不能正常显示")]),t._v(" "),s("p",[s("strong",[t._v("摘要算法")]),t._v("的方式来实现"),s("strong",[t._v("完整性")]),t._v("，它能够为数据生成独一无二的「指纹」，指纹用于校验数据的完整性，解决了篡改的风险。")])]),t._v(" "),s("li",[s("p",[s("strong",[t._v("身份证书")]),t._v("：CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的")]),t._v(" "),s("p",[t._v("将服务器公钥放入到"),s("strong",[t._v("数字证书")]),t._v("中，解决了冒充的风险。")])])]),t._v(" "),s("p",[t._v("详见"),s("RouterLink",{attrs:{to:"/笔记整理/浏览器与计网/HTTPS加密过程.html"}},[t._v("(HTTPS加密过程)")])],1),t._v(" "),s("h2",{attrs:{id:"参考"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[t._v("#")]),t._v(" 参考")]),t._v(" "),s("p",[s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2016/08/http.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("HTTP 协议入门 - 阮一峰的网络日志 (ruanyifeng.com)"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("strong",[t._v("图解HTTP")])]),t._v(" "),s("p",[s("strong",[t._v("小林coding")])]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/43789231",target:"_blank",rel:"noopener noreferrer"}},[t._v("彻底搞懂HTTPS的加密原理 - 知乎 (zhihu.com)"),s("OutboundLink")],1)]),t._v(" "),s("p",[s("a",{attrs:{href:"https://juejin.cn/post/6844903764399243278#heading-8",target:"_blank",rel:"noopener noreferrer"}},[t._v("完全图解 HTTPS - 掘金 (juejin.cn)"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=_.exports}}]);