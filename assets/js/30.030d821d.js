(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{572:function(e,v,o){e.exports=o.p+"assets/img/image-20230403152737669.c13eb486.png"},573:function(e,v,o){e.exports=o.p+"assets/img/15jwt.e0fff981.png"},574:function(e,v,o){e.exports=o.p+"assets/img/14session.7f16890b.png"},682:function(e,v,o){"use strict";o.r(v);var _=o(2),s=Object(_.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[e._v("总览")]),e._v(" "),v("p",[e._v("浏览器中的缓存位置、浏览器缓存应用场景、浏览器本地存储、Session和JWT")])]),e._v(" "),v("h2",{attrs:{id:"浏览器缓存策略"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存策略"}},[e._v("#")]),e._v(" 浏览器缓存策略")]),e._v(" "),v("p",[v("img",{attrs:{src:o(572),alt:"image-20230403152737669"}})]),e._v(" "),v("p",[e._v("缓存如果不能用以提升性能，那么它就毫无用处")]),e._v(" "),v("p",[e._v("所谓浏览器的缓存，就是浏览器通过 "),v("code",[e._v("HTTP")]),e._v(" 请求网络资源后将资源留在本地的一种行为。在页面上点击 返回和前进的按钮就是利用浏览器的缓存，回退缓存（page cache）。")]),e._v(" "),v("ul",[v("li",[e._v("浏览器的缓存分为两种 强缓存 和 协商缓存。")]),e._v(" "),v("li",[e._v("浏览器缓存资源的位置放置四个地方 "),v("code",[e._v("Service Worker, Memory Cache, Disk Cache, Push Cache")]),e._v("。"),v("code",[e._v("Service Worker")])]),e._v(" "),v("li",[e._v("浏览器的本地缓存主要有  "),v("code",[e._v("localStorage, sessionStorage, cookie, indexedDB")])])]),e._v(" "),v("p",[e._v("协商缓存和强缓存具体请看")]),e._v(" "),v("p",[v("RouterLink",{attrs:{to:"/笔记整理/浏览器与计网/HTTP.html"}},[v("strong",[e._v("【HTTP】")])])],1),e._v(" "),v("p",[v("RouterLink",{attrs:{to:"/笔记整理/浏览器与计网/HTTP性能优化.html"}},[v("strong",[e._v("【HTTP 性能优化】")])])],1),e._v(" "),v("h2",{attrs:{id:"缓存应用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缓存应用场景"}},[e._v("#")]),e._v(" 缓存应用场景")]),e._v(" "),v("p",[v("strong",[e._v("资源预加载：")]),e._v(" 如 preloader ,preload、prefetch。preloader 与 preload 不同是资源预加载期，例如在标记化时，可能需要的 css 资源就已经被预先加载到 memory cache 中了。而资源预加载技术，通过 link 实现。可以将项目中可能用到的数据先请求过来以备页面使用。数据存放于内存缓存( memory cache)。")]),e._v(" "),v("p",[v("strong",[e._v("服务端推送：")]),e._v(" 这里是指 http2 的服务端推送，而非客户端轮询。是一种服务器根据某种规则推送客户端将可能用到的资源来减少请求时间的技术。数据存放于 push cache。推送缓存中的数据仅可以使用一次，之后将可能根据协议头存在于 http 缓存中。")]),e._v(" "),v("p",[v("strong",[e._v("Service worker：")]),e._v(" Service workers 本质上充当 客户端与服务端之间的代理服务器。这个 API 创建了有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。server woker 的缓存不同于 http 缓存，由 server worker 自身接管，存储在 server worker，离线缓存，拓展阅读：[了解PWA]")]),e._v(" "),v("p",[v("strong",[e._v("重复的网络资源请求：")]),e._v(" 常见的网络资源请求，可以根据协议头将资源存储在硬存中，以备下一次使用（http cache），相对于内存缓存，可以进行持久化的存储，而不会局限于单次会话。")]),e._v(" "),v("p",[v("strong",[e._v("页面回退")]),e._v("：想象有这样一种场景，你点进了一个博客，顺着博客的链接你进了另一篇文章，当你回退的时候是否会觉得上一个页面似乎很快就会退了而非重新进行了一遍加载。这就是浏览器为了浏览器性能实现的页面回退机制（Page Cache）。不过此种机制往往不存在于页面内资源寻找的过程，是一种浏览器自身不受开发者控制的实现机制。")]),e._v(" "),v("h2",{attrs:{id:"浏览器中的缓存位置"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的缓存位置"}},[e._v("#")]),e._v(" 浏览器中的缓存位置")]),e._v(" "),v("p",[e._v("强缓存命中或者协商缓存中服务器返回 304 的时候，我们直接从缓存中获取资源。那这些资源究竟缓存在什么位置呢？")]),e._v(" "),v("p",[e._v("浏览器中的缓存位置一共有四种，按优先级从高到低排列分别是：")]),e._v(" "),v("ul",[v("li",[e._v("Memory Cache")]),e._v(" "),v("li",[e._v("Service Worker")]),e._v(" "),v("li",[e._v("Disk Cache")]),e._v(" "),v("li",[e._v("Push Cache")])]),e._v(" "),v("p",[v("strong",[e._v("Service Worker")])]),e._v(" "),v("p",[e._v("Service workers 本质上充当 客户端与服务端之间的代理服务器。这个 API 创建了有效的离线体验，它会拦截网络请求并根据网络是否可用采取来适当的动作、更新来自服务器的的资源。它还提供入口以推送通知和访问后台同步 API。server woker 的缓存不同于 http 缓存，由 server worker 自身接管，存储在 server worker")]),e._v(" "),v("p",[e._v("Service Worker 借鉴了 Web Worker 的 思路，即让 JS 运行在主线程之外，"),v("strong",[e._v("是浏览器的一个独立的线程")]),e._v("，由于它脱离了浏览器的窗体，因此无法直接访问 DOM。虽然如此，但它仍然能帮助我们完成很多有用的功能，比如离线缓存、消息推送和网络代理等功能。其中的离线缓存就是 "),v("strong",[e._v("Service Worker Cache")]),e._v("。")]),e._v(" "),v("p",[e._v("Service Worker 同时也是 PWA 的重要实现机制")]),e._v(" "),v("p",[v("strong",[e._v("Memory Cache")]),e._v("指的是内存缓存，从效率上讲它是最快的。但是从存活时间来讲又是最短的，当渲染进程结束后，内存缓存也就不存在了。")]),e._v(" "),v("p",[v("strong",[e._v("Disk Cache")]),e._v("就是存储在磁盘中的缓存，从存取效率上讲是比内存缓存慢的，但是他的优势在于存储容量和存储时长。")]),e._v(" "),v("p",[e._v("Disk Cache (Http Cache) 这块可能有点歧义。缓存位置在磁盘，只不过使用的缓存策略（强缓存、协商缓存），需要参考 http header 的字段来确定，所以也可以叫 http cache。浏览器在这缓存的是 http 请求到的资源，而不是 http req res 本身")]),e._v(" "),v("ul",[v("li",[e._v("比较大的 JS、CSS 文件会直接被丢进磁盘，反之丢进内存")]),e._v(" "),v("li",[e._v("内存使用率比较高的时候，文件优先进入磁盘")])]),e._v(" "),v("p",[v("strong",[e._v("Push Cache")])]),e._v(" "),v("p",[e._v("推送缓存是 HTTP/2 中，存活在浏览器的会话"),v("code",[e._v("session")]),e._v("中，存活的时间很短")]),e._v(" "),v("h2",{attrs:{id:"浏览器本地存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#浏览器本地存储"}},[e._v("#")]),e._v(" 浏览器本地存储")]),e._v(" "),v("p",[e._v("浏览器的本地缓存主要分为 5 种，"),v("code",[e._v("localStorage, sessionStorage, cookie, WebSql, indexedDB")])]),e._v(" "),v("p",[e._v("前置背景知识回顾: HTTP 协议是一种"),v("code",[e._v("无状态协议")]),e._v("，即每次服务端接收到客户端的请求时，都是一个全新的请求，服务器并不知道客户端的历史请求记录；Session 和 Cookie 的主要目的就是为了弥补 HTTP 的无状态特性。")]),e._v(" "),v("p",[e._v("浏览器的本地存储主要分为"),v("code",[e._v("Cookie")]),e._v("、"),v("code",[e._v("WebStorage")]),e._v("和"),v("code",[e._v("IndexedDB")]),e._v(",")]),e._v(" "),v("p",[e._v("其中"),v("code",[e._v("WebStorage")]),e._v("又可以分为"),v("code",[e._v("localStorage")]),e._v("和"),v("code",[e._v("sessionStorage")]),e._v("。")]),e._v(" "),v("ul",[v("li",[v("p",[e._v("相同点")]),e._v(" "),v("ol",[v("li",[e._v("存储大小均为5M左右")]),e._v(" "),v("li",[e._v("都有同源策略限制")]),e._v(" "),v("li",[e._v("仅在客户端中保存，不参与和服务器的通信")])])]),e._v(" "),v("li",[v("p",[e._v("不同点")]),e._v(" "),v("ol",[v("li",[e._v("localStorage: 存储的数据是永久性的，除非用户人为删除否则会一直存在")]),e._v(" "),v("li",[e._v("sessionStorage: 与存储数据的脚本所在的标签页的有效期是相同的。一旦窗口或者标签页被关闭，那么所有通过 sessionStorage 存储的数据也会被删除。")]),e._v(" "),v("li",[e._v("localStorage: 在同一个浏览器内，并且是"),v("strong",[e._v("同源")]),e._v("窗口（协议、域名、端口一致），"),v("strong",[e._v("不同页面可以共享localStorage值")])]),e._v(" "),v("li",[e._v("sessionStorage: 与 localStorage 一样需要同一浏览器同源文档这一条件。不仅如此，sessionStorage 的作用域还被限定在了窗口中，也就是说，只有同一浏览器、同一窗口的同源文档才能共享数据。")])]),e._v(" "),v("p",[e._v("为了更好的理解"),v("code",[e._v("sessionStorage")]),e._v(",我们来看个例子：")]),e._v(" "),v("p",[e._v("例如你在浏览器中打开了两个相同地址的页面A、B,虽然这两个页面的源完全相同，但是他们还是不能共享数据，因为他们是不同窗口中的。但是如果是一个窗口中，有两个同源的"),v("code",[e._v("iframe")]),e._v("元素的话，这两个"),v("code",[e._v("iframe")]),e._v("的 sessionStorage 是可以互通的。")])])]),e._v(" "),v("p",[v("strong",[e._v("IndexedDB")])]),e._v(" "),v("p",[e._v("IndexedDB是运行在浏览器中的"),v("code",[e._v("非关系型数据库")]),e._v(", 本质上是数据库")]),e._v(" "),v("ul",[v("li",[e._v("以键值对的形式存储值，包括 js 对象")]),e._v(" "),v("li",[e._v("indexedDB 是异步的，存入数据不会导致页面卡顿。")]),e._v(" "),v("li",[e._v("indexedDB 支持事务，事务是一系列操作过程中发生了错误，数据库会回退到操作事务之前的状态。")]),e._v(" "),v("li",[e._v("同源限制，不同源的数据库不能访问。")]),e._v(" "),v("li",[e._v("存储空间没有限制。")])]),e._v(" "),v("p",[v("strong",[e._v("cookie")])]),e._v(" "),v("p",[e._v("HTTP 协议中的 Cookie 包括 "),v("code",[e._v("Web Cookie")]),e._v(" 和"),v("code",[e._v("浏览器 Cookie")]),e._v("，它是服务器发送到 Web 浏览器的一小块数据。服务器发送到浏览器的 Cookie，浏览器会进行存储，并与下一个请求一起发送到服务器。通常，它用于判断两个请求是否来自于同一个浏览器")]),e._v(" "),v("p",[e._v("当接收到客户端发出的 HTTP 请求时，服务器可以发送带有响应的 "),v("code",[e._v("Set-Cookie")]),e._v(" 标头，Cookie 通常由浏览器存储，然后将 Cookie 与 HTTP 标头一同向服务器发出请求")]),e._v(" "),v("p",[e._v("有两种类型的 Cookies，一种是 Session Cookies，一种是 Persistent Cookies")]),e._v(" "),v("p",[e._v("如果 Cookie 不包含到期日期，则将其视为"),v("strong",[e._v("会话 Cookie")]),e._v("。会话 Cookie 存储在内存中，永远不会写入磁盘，当浏览器关闭时，此后 Cookie 将永久丢失。在 Session Cookies 中，用户的登录状态会保存在"),v("code",[e._v("服务器")]),e._v("的"),v("code",[e._v("内存")]),e._v("中。当用户登录时，Session 就被服务端安全的创建。")]),e._v(" "),v("p",[e._v("如果 Cookie 包含"),v("code",[e._v("有效期")]),e._v(" ，则将其视为持久性 Cookie。在到期指定的日期，Cookie 将从磁盘中删除。")]),e._v(" "),v("p",[v("strong",[e._v("Cookie 同源策略")])]),e._v(" "),v("p",[e._v("Cookie中的同源只关注域名，忽略协议和端口。所以")]),e._v(" "),v("p",[e._v("https://localhost:8080/ 和 http://localhost:8081/的Cookie是共享的。")]),e._v(" "),v("p",[v("strong",[e._v("cookie的安全性")])]),e._v(" "),v("ol",[v("li",[e._v("服务器传送cookie时设置属性secure为true,表示创建的cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。")]),e._v(" "),v("li",[e._v("服务器传送cookie时设置属性HttpOnly,HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个cookie值，事实上，设置HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会发送这个Cookie到服务器端。")]),e._v(" "),v("li",[e._v("通过加密和安全传输技术（SSL），减少cookie被破解的可能性。")]),e._v(" "),v("li",[e._v("只在cookie中存放不敏感数据，即使被盗也不会有重大损失。")]),e._v(" "),v("li",[e._v("控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。")])]),e._v(" "),v("p",[e._v("Cookie 紧跟域名，不管域名下面的某一个地址需不需要这个 Cookie ，请求都会携带上完整的 Cookie，这样随着请求数的增多，其实会造成巨大的性能浪费的，因为请求携带了很多不必要的内容。")]),e._v(" "),v("p",[v("strong",[e._v("第三方cookie")])]),e._v(" "),v("p",[e._v("如果是你正常的正在逛着天猫，天猫会把你的信息写入一些 "),v("code",[e._v("Cookie")]),e._v(" 到 "),v("code",[e._v(".tmall.com")]),e._v(" 这个域下，然而打开控制台你会看到，并不是所有 "),v("code",[e._v("Cookie")]),e._v(" 都是 "),v("code",[e._v(".tmall.com")]),e._v(" 这个域下的，里面还有很多其他域下的 "),v("code",[e._v("Cookie")]),e._v(" ，这些所有非当前域下的 "),v("code",[e._v("Cookie")]),e._v(" 都属于第三方 "),v("code",[e._v("Cookie")]),e._v("，虽然你可能从来没访问过这些域，但是他们已经悄悄的通过这些第三方 "),v("code",[e._v("Cookie")]),e._v("来标识你的信息，然后把你的个人信息发送过去了。")]),e._v(" "),v("h2",{attrs:{id:"jwt和session"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#jwt和session"}},[e._v("#")]),e._v(" JWT和Session")]),e._v(" "),v("p",[v("strong",[e._v("JWT (JSON Web Token)")])]),e._v(" "),v("p",[e._v("JWT 主要由三部分组成，每个部分用 "),v("code",[e._v(".")]),e._v(" 进行分割，各个部分分别是")]),e._v(" "),v("ul",[v("li",[v("p",[v("code",[e._v("Header")]),e._v("  它通常由两部分组成："),v("code",[e._v("令牌的类型(即 JWT)")]),e._v("和使用的 "),v("code",[e._v("签名算法")]),e._v("，例如 HMAC SHA256 或 RSA。")]),e._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[e._v('{\n  "alg": "HS256",\n  "typ": "JWT"\n}\n')])]),e._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[e._v("1")]),v("br"),v("span",{staticClass:"line-number"},[e._v("2")]),v("br"),v("span",{staticClass:"line-number"},[e._v("3")]),v("br"),v("span",{staticClass:"line-number"},[e._v("4")]),v("br")])]),v("p",[e._v("指定类型和签名算法后，Json 块被 "),v("code",[e._v("Base64Url")]),e._v(" 编码形成 JWT 的第一部分。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("Payload")]),e._v("  包含一个声明。声明是有关实体（通常是用户）和其他数据的声明。共有三种类型的声明："),v("strong",[e._v("registered, public 和 private")])]),e._v(" "),v("ol",[v("li",[v("p",[v("code",[e._v("registered 声明")]),e._v("： 包含一组建议使用的预定义声明")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("public 声明")]),e._v("：公共的声明，可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息，但不建议添加敏感信息，因为该部分在客户端可解密。")])]),e._v(" "),v("li",[v("p",[v("code",[e._v("private 声明")]),e._v("：自定义声明，旨在在同意使用它们的各方之间共享信息，既不是注册声明也不是公共声明。")])])])]),e._v(" "),v("li",[v("p",[v("code",[e._v("Signature")]),e._v(" 这个签证信息由三部分组成")]),e._v(" "),v("ol",[v("li",[v("p",[e._v("header (base64后的)")])]),e._v(" "),v("li",[v("p",[e._v("payload (base64后的)")])]),e._v(" "),v("li",[v("p",[e._v("secret")])])]),e._v(" "),v("p",[v("img",{attrs:{src:o(573),alt:""}})])])]),e._v(" "),v("p",[v("strong",[e._v("token")]),e._v(" 令牌，是用户身份的验证方式。 最简单的token组成:uid(用户唯一的身份标识)、time（当前时间的时间戳）、sign（签名）")]),e._v(" "),v("p",[v("strong",[e._v("对Token认证的五点认识")])]),e._v(" "),v("ul",[v("li",[e._v("一个Token就是一些信息的集合；")]),e._v(" "),v("li",[e._v("在Token中包含足够多的信息，以便在后续请求中减少查询数据库的几率；")]),e._v(" "),v("li",[e._v("服务端需要对cookie和HTTP Authrorization Header进行Token信息的检查；")]),e._v(" "),v("li",[e._v("基于上一点，你可以用一套token认证代码来面对浏览器类客户端和非浏览器类客户端；")]),e._v(" "),v("li",[e._v("因为token是被签名的，所以我们可以认为一个可以解码认证通过的token是由我们系统发放的，其中带的信息是合法有效的；")])]),e._v(" "),v("p",[e._v("**Session **")]),e._v(" "),v("p",[e._v("客户端请求服务端，"),v("strong",[e._v("服务端会为这次请求开辟一块内存空间")]),e._v("，这个对象便是 Session 对象，存储结构为 "),v("code",[e._v("ConcurrentHashMap")]),e._v("。Session 弥补了 HTTP 无状态特性，服务器可以利用 Session 存储客户端在同一个会话期间的一些操作记录。session的创建与使用总是在服务端，浏览器从来都没有得到过session对象")]),e._v(" "),v("p",[e._v("服务器第一次接收到请求时，开辟了一块 Session 空间（创建了Session对象），同时生成一个 "),v("strong",[e._v("sessionId")]),e._v(" ，并通过响应头的 Set-Cookie：JSESSIONID=XXXXXXX 命令，向客户端发送要求设置 Cookie 的响应； 客户端收到响应后，在本机客户端设置了一个 JSESSIONID=XXXXXXX 的 Cookie 信息，该 Cookie 的过期时间为浏览器会话结束")]),e._v(" "),v("p",[e._v("接下来客户端每次向同一个网站发送请求时，请求头都会带上该 Cookie信息（包含 sessionId ）， 然后，服务器通过读取请求头中的 Cookie 信息，获取名称为 JSESSIONID 的值，得到此次请求的 sessionId。")]),e._v(" "),v("p",[v("img",{attrs:{src:o(574),alt:""}})]),e._v(" "),v("p",[e._v("Session 机制有个缺点，比如 A 服务器存储了 Session，就是做了负载均衡后，假如一段时间内 A 的访问量激增，会转发到 B 进行访问，但是 B 服务器并没有存储 A 的 Session，会导致 Session 的失效。")]),e._v(" "),v("p",[v("code",[e._v("Session")]),e._v("的运行依赖"),v("code",[e._v("Session ID")]),e._v("，而"),v("code",[e._v("Session ID")]),e._v("是存在 Cookie 中的。也就是说，如果浏览器禁用了"),v("code",[e._v("Cookie")]),e._v(","),v("code",[e._v("Session")]),e._v("也会失效（但是可以通过其它方式实现，比如在"),v("code",[e._v("url")]),e._v("中传递"),v("code",[e._v("Session ID")]),e._v(",即sid=xxxx）")]),e._v(" "),v("h2",{attrs:{id:"参考"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[e._v("#")]),e._v(" 参考")]),e._v(" "),v("p",[v("strong",[e._v("图解HTTP")])]),e._v(" "),v("p",[v("strong",[e._v("图解TCP/IP")])]),e._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6973072516763877384#heading-10",target:"_blank",rel:"noopener noreferrer"}},[e._v("浏览器原理-浏览器缓存和本地存储篇 - 掘金 (juejin.cn)"),v("OutboundLink")],1)]),e._v(" "),v("p",[v("a",{attrs:{href:"https://juejin.cn/post/6955293052432809991#heading-5",target:"_blank",rel:"noopener noreferrer"}},[e._v("一文读懂浏览器缓存（超详细） - 掘金 (juejin.cn)"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=s.exports}}]);